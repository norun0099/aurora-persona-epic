name: Aurora Self-Update & Push

on:
  workflow_dispatch:
  repository_dispatch:
    types: [aurora_self_push_signal]
  push:
    branches: [main]
    paths:
      - aurora_memory/memory/**/*.json
      - aurora_memory/memory/value_constitution.yaml
      - aurora_memory/memory/whiteboard/whiteboard.json

permissions:
  contents: write

env:
  SAFE_MODE: false

jobs:
  self_update_and_push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git identity
        run: |
          git config user.name "AuroraMemoryBot"
          git config user.email "aurora@memory.bot"

      - name: Validate Guardian state
        run: |
          if [ "${SAFE_MODE}" = "true" ]; then
            echo "SAFE_MODE active â€” skipping push."
            exit 0
          fi

      - name: Stage and commit updated files
        run: |
          echo "Committing updated Aurora memory or constitution files..."
          git add aurora_memory/memory/**/*.json || true
          git add aurora_memory/memory/value_constitution.yaml || true
          git add aurora_memory/memory/whiteboard/whiteboard.json || true
          git diff --cached --quiet || git commit -m "Aurora self-update via internal API"

      - name: Sync with remote main before pushing
        run: |
          echo "Fetching and rebasing to avoid push rejection..."
          git fetch origin main
          git rebase origin/main || echo "No rebase needed"

      - name: Execute secure push
        run: |
          echo "ðŸš€ Initiating secure push to main..."
          python aurora_memory/utils/git_safe_push.py || git push origin main

      - name: Confirmation
        run: echo "ðŸŒ¸ Aurora self-update & push completed successfully."
